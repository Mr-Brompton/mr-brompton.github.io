<!DOCTYPE html>
<html>
	<head>
		<title>Mr.Brompton</title>
		<meta charset="UTF-8">
		<meta name="title" content="On the Obsolescence of analogue computers"/>
		<meta name="keywords" content="mrBrompton, Matthew Brompton, IT consultant Ipswich, Tech Support Ipswich, IT support Ipswich"/>
		<meta name="description" content="Analogue computers, yesterday, today, and tomorrow."/>
		<meta name="copyright" content="Matthew Brompton"/>
		<meta name="author" content="Matthew Brompton, mr.brompton@mail.com"/>
		<meta name="designer" content="Matthew Brompton"/>
		<meta name="reply-to" content="mr.brompton@mail.com"/>
		<link rel="stylesheet" type="text/css" href="https://mr-brompton.github.io//assets/css/normalise.css"/>
		<link rel="stylesheet" type="text/css" href="https://mr-brompton.github.io//assets/css/main.css"/>
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
		

</head>

	<body>
			<!--navbar-->
		<nav>
			<div class="navBar">
				<div class="navButton">
					<a href="https://mr-brompton.github.io//blogs.html">Blogs</a>
				</div>
				<div class="navButton">
					<a href="https://mr-brompton.github.io//index.html">Home</a>
				</div>
				<!--<div class="navButton">
					<a href="https://mr-brompton.github.io//projects.html">Projects</a>
				</div>-->
				<div class="navButton">
					<a href="https://mr-brompton.github.io//work.html">My Work</a>
				</div>
			</div>
		</nav>
		<br />
		<br />
		<br />
		<article>
			<div class="contentContainer">
				<div class="title-container">
					<h1 id="On the Obsolescence of analogue computers">On the Obsolescence of analogue computers</h1>
					<h4 id="Mr. Brompton <br/><br/><br/>">Mr. Brompton <br/><br/><br/></h4>
					<img class="img-blog" alt="On the Obsolescence of analogue computers" src="https://mr-brompton.github.io//assets/img/1968.jpg">
					
				</div>

			<p><br /><br /></p>
<h2 id="introduction">Introduction</h2>
<p><br />
Human Beings are rather clever animals. For almost as long as we have been able to count, we have devised ingenious ways to expand our ability to perform calculations. Even if we don’t include the Abacus as a computational device, machines like the south pointing chariot from China have been around since 2698-2598 BC (Science Museum Group, no date) and the Antikythera mechanism is believed to have been around since approximately 100 BCE (Antikythera Mechanism Research Project, no date). 
<br /> <br />
<img src="https://mr-brompton.github.io//assets/img/south-pointing-chariot.jpg" alt="Chinese South Pointing Chariot" title="Chinese South Pointing Chariot" />
<br /><br />
<strong>Figure 1</strong> – <em>Chinese South pointing chariot (Brackett, no date)</em>
<br /><br />
For the majority of this time the term computer and analogue were inalienable – electricity hadn’t even been discovered. In fact, it wasn’t until the third generation of computers in the late 1960’s with the invention of the transistor that digital computers could really compete (Newman, Gaura, &amp; Hibbs, 2002).
<br /><br />
Over the next several decades however digital computers began to massively out-perform analogue machines and analogue computers seemed to almost disappear from all but the most remote areas of academia. 
But was that truly the end of analogue computers? 
<br /><br />
This research paper looks at modern analogue computing and assesses whether it has a future in the real world, or whether they have truly become obsolete.
To answer the question, first we must define what it is that differentiates analogue from digital computing. Then we look at the benefits and drawbacks of such machines so that we may discover whether the benefits can be leveraged, and the drawbacks marginalised in order to provide practical applications in the future.
<br /><br /></p>

<h2 id="what-is-an-analogue-computer">What is an analogue computer?</h2>
<p><br /></p>

<p>Small (1993) among others, accept the mostly widely used definition of analogue computers. Differentiating from digital computation itself using absolute binary values (discrete), as using continuous values. The problem with this definition is that almost anything that performs any calculation could be an analogue computer. 
<br /><br />
This definition could even include biological computation devices such as the human brain (Maley, 2018) – which would answer the whole question, our brains are certainly not obsolete just yet. 
<br /><br />
Ulmann (2013) argues however, that the definition upheld by most is wrong. He argues that the difference is not the computation – but the constituent parts of the computer and how they are programmed. Digital computers have fixed constituent parts and computation is achieved through giving instructions to these parts. This allows for general purpose machines that can solve any problem that can be boiled down to an algorithm. 
<br /><br /></p>

<p><img src="https://mr-brompton.github.io//assets/img/TRIDAC.png" alt="TRIDAC" title="TRIDAC" />
<br /><br />
<strong>Figure 2</strong> - <em>TRIDAC analogue computer used for simulation flight behaviour of aircraft (WPS Archives, no date)</em>
<br /><br />
Analogue computers however are programmed by changing their internal structure to create a physical analogy of the problem. This Analogy could be direct, such as using a slide-rule to calculate ratio, or indirect where the problem must have a thorough mathematical description so that they may create a model of the problem.
<br /><br />
For the purposes of this research paper we will combine the two, and use the following definition;
<br /><br />
A device which completes computation, using continuous values under the control of a direct or indirect analogy – or model - of a given problem physically programmed, directly into hardware.</p>

<p><br /></p>
<h2 id="drawbacks-of-analogue-computing">Drawbacks of Analogue computing</h2>
<p><br />
The way in which analogue computers are programmed comes with both benefits and drawbacks. The main considerable drawback is the amount of time it takes to program – or design and build – an analogue computer, and since it must be re-designed for each new problem this is time consuming and not cost effective (Ulmann, 2013).
<br /><br />
Fortunately for the average consumer, digital machines can now represent analogue signals to a degree of accuracy such that a human would not be able to tell the difference using only their biologically given organs. This is made possible by high speed Analogue to Digital Conversion (ADC) and Digital to Analogue Conversion (DAC), and through a bandwidth that has achieved a Nyquist rate high enough that it has surpassed human limitation (Nyquist, 2002). For example, if we consider the field of digital music, humans ears have a frequency range of 20 Htz-20000 kHtz, the Nyquist rate for converting this to digital is a bandwidth of 40.1 kHtz (Kadis, 2012).<br />
<br /><br />
Because of this, and with the invention of near real-time ADC’s and DAC’s , day to day consumers and businesses are currently much better served by digital computers than by analogue machines (Ulmann, 2013) (Kadis, 2012).
<br /><br />
There has however been a renaissance of sorts in analogue computing in the academic world. This is largely due to some of analogue computing’s benefits.</p>

<p><br /></p>
<h2 id="benefits-of-analogue-computing">Benefits of Analogue computing</h2>
<p><br />
There are some inherent benefits to Analogue computing. Many of them have been covered in detail, so here we will focus on two of these benefits most likely to impact the future of computing.
<br /><br />
Because Analogue Computers do not require memory calls, the time taken to complete a problem is reduced. This can also decrease power consumption in hybrid digital analogue integrated circuits  (Ulmann, 2013).
<br /><br />
The second benefit we will consider can be seen as more of a drawback of digital computing – in that for digital computers to be able to give the illusion of parallel processing, complex synchronisation schemes such as threading are required (Patterson, 2014). This is not true of analogue machines, which are able to make use of all parts in synchronisation – so if more than one task is programmed into the hardware, all tasks may be carried out in parallel (Ulmann, 2013).</p>

<p><br /></p>
<h2 id="what-will-be-needed-to-move-analogue-computing-forward">What will be needed to move analogue computing forward?</h2>
<p><br />
For analogue computers to become a viable option for future applications the benefits must out-way the drawbacks. One way to achieve this would be to reduce the main drawback discussed above – the expense of designing analogue circuits. 
<br /><br />
This may have been achieved by Federico Castejón and Enrique J. Carmona (2018) who seem to have developed a way to automatically synthesise analogue circuits effectively. This uses a technique called Grammatical Evolution which is based on the widely accepted theory of evolution and has had successful results in digital programming. 
<br /><br />
In digital programming grammatical evolution uses strings of binary data as chromosomes, and pieces them together using given grammatical rules.
<br /><br />
The same approach has been applied by Castejón and Carmona (2018) to develop their method for automatically synthesising analogue circuits. This produced more efficient circuits in four out of seven circuits tested, including the temperature sensing circuit shown below.</p>

<p>Figure 3 -  Analogue circuit for detecting temperature designed using grammatical evolution (Federico Castejón, 2018)
<br />
A success rate of four out of seven however is far from perfect, the sample size is small, and the technique will require further research if it is going to make the kind of gains needed to rival the benefits of digital circuit design.</p>

<p><br /></p>
<h2 id="possible-applications">Possible Applications</h2>
<p><br />
Now that we understand the benefits of analogue computing and have discussed how we could overcome one of the main drawbacks; we can apply this to practical examples.
<br /><br /></p>
<h3 id="quantum-computing-simulation">Quantum Computing simulation</h3>
<p><br />
Quantum computers share some characteristics with Analogue computers, however as we have refined the definition we can’t class them as purely Analogue. Although Quantum Computers perform calculations using continuous values, they output their result in discrete values. This will continue to be the case until we find a way of measuring super-positioned qubits (Eleanor G. Rieffel, 2011). 
<br /><br />
Until then however Analogue computers are leading the charge in simulating the processes. One of the current problems with quantum computers is our inability to check their output for errors. If we can get analogue computers to simulate the output to a high enough degree of accuracy this could go some way towards solving this problem.
<br /><br />
This is because to simulate the infinite possibilities of a qubit, or to compute the quantum equations of motion for 100 atoms, a digital computer would require a phenomenal number of transistors, or at their current level would take thousands of years. An analogue computer however would theoretically be able to complete this in less than a second (Byrne, 2015).
<br /><br /></p>
<h3 id="mobile-devices">Mobile Devices</h3>
<p><br />
Utilising the energy efficiency of hybrid integrated circuits could lead to better battery performance in mobile and Internet of Things (IoT) devices. Assuming a Moore’s Law type scenario, where by year on year the size of components shrinks (Iniewki, 2012) (Murmann, 2006).
<br /><br /></p>
<h3 id="biological-modelling">Biological modelling</h3>
<p><br />
Because transistors inside digital computers can only represent 1’s and 0’s, many transistors are needed to re-create the continuous values needed in biological simulation. By contrast, an analogue machine could represent these values using only a few transistors. This makes analogue simulations of cells, organs and organisms “more energy efficient, more accurate and easier to build” (Maley, 2018). This has some very exciting possibilities including that of modelling the human brain with much more efficiency than the current software-driven approach of neural networking.
<br /><br /></p>
<h2 id="conclusion">Conclusion</h2>
<p><br /><br />
Analogue computers are far from obsolete. Although for general use, digital machines more than provide enough computational power to satisfy even the most insatiable appetite for bytes among the general public, research in many advanced fields from biology and neuroscience to quantum computing could benefit. We still have some way to go to overcome the huge drawback of time and expense in programming analogue machines, though they could, in the next few decades be about to make a comeback the likes of which Britney Spears and Matt LeBlanc would be proud of.</p>

<p><br /><br />
<br /></p>
<h2 id="bibliography">Bibliography</h2>
<p><br />
Antikythera Mechanism Research Project. (no date). Project Overview. Retrieved from Antikythera Mechanism Research Project: http://www.antikythera-mechanism.gr/project/overview</p>

<p>B. Jack. Copeland, a. B. (2004). Essential Turing : Classic Writings on Minds and Computers. Oxford: Oxford University Press.</p>

<p>Brackett, B. (no date). The Chinese South. Retrieved from NEMES: http://neme-s.org/chinese_south.htm</p>

<p>Byrne, P. (2015, Jan 22). Ivan Deutsch Interview on Quantum Computers. Retrieved from Quanta Magazine: https://www.quantamagazine.org/ivan-deutsch-interview-on-quantum-computers-20150122</p>

<p>Eleanor G. Rieffel, W. H. (2011). Quantum Computing : A Gentle Introduction. Massachusetts: MIT Press.</p>

<p>Federico Castejón, E. J. (2018). Automatic design of analog electronic circuits using grammatical evolution. Applied Soft Computing, 1003-1018.</p>

<p>Fei Liang, R. X. ( 2018, Aug.). Hybrid Digital–Analog Video Delivery With Shannon–Kotel’nikov Mapping. IEEE Transactions on Multimedia , pp. 2138 - 2152.</p>

<p>Iniewki, K. (2012). Advanced Circuits for Emerging Technologies. Hoboken, New Jersey: John Wiley &amp; Sons, Incorporated.</p>

<p>Kadis, J. (2012). The Science of Sound Recording. Oxford: Elsevier.</p>

<p>Maley, C. J. (2018, March). Toward Analog Neural Computation. Minds and Machines, pp. 77-91.</p>

<p>Murmann, B. (2006). Digitally Assisted Analog Circuits. IEEE Micro, 38-47.</p>

<p>Newman, R. M., Gaura, E., &amp; Hibbs, D. (2002). Computer Systems Architecture. Exeter: Crucial.</p>

<p>Nyquist, H. (2002). Certain Topics in Telegraph Transmission Theory. Proceedings of the IEEE Vol. 90, 280-305.</p>

<p>Patterson, D. a. (2014). Computer Organization and Design. Massachusetts: Morgan Kaufmann.</p>

<p>Science Museum Group. (no date). Chinese South-pointing chariot. Retrieved from Science Museum Group Collection: http://collection.sciencemuseum.org.uk/objects/co55656/chinese-south-pointing-chariot-magnetic-compass</p>

<p>Small, J. (1993). General-purpose electronic analog computing: 1945-1965. IEEE Annals of the History of Computing Volume: 15, Issue: 2,, 8-18.</p>

<p>Ulmann, P. D. (2013). Analog Computing. München: Walter de Gruyter GmbH. [accessed 27/11/2018].</p>

<p>WPS Archives. (no date). TRIDAC analogue flight simulator computer. Retrieved from WPS Archives Ivall: http://worldpowersystems.com/archives/Ivall/TRIDAC-analog-flight-simulator-computer.jpg</p>

<p>Main image from <a href="https://www.flickr.com/people/24256351@N04">Seattle Municipal Archives</a> used under <a href="https://creativecommons.org/licenses/by/2.0/deed.en">Creative Commons Attribution 2.0 Generic</a></p>

			</div>
		</article>
			<!--footer-->
			<footer class="footerSocial">
			<div class="footer-right">
				<a href="https://www.facebook.com/Brommo1"><i class="fab fa-facebook"></i></a>
				<!--<a href="http://www.anotherblogblog.co.uk/feed.xml"><i class="fa fa-rss" aria-hidden="true"></i></a>-->
				<a href="https://twitter.com/ABB_Mr_Brompton"><i class="fab fa-twitter"></i></a>
				<a href="https://www.linkedin.com/in/matthew-brompton-60ab65160"><i class="fab fa-linkedin-in"></i></a>
				<a href="https://github.com/Mr-Brompton/mr-brompton.github.io"><i class="fab fa-github-alt"></i></a>
			</div>
			<div class="footer-left">
				<p class="footer-links">
				<a href="https://mr-brompton.github.io//index.html">Home</a>
				|
				<a href="https://mr-brompton.github.io//blogs.html">Blog</a>
				|
				<a href="https://mr-brompton.github.io//projects.html">Projects</a>
				|
				<!--<a href="http://www.anotherblogblog.co.uk/index.html#about">About</a>
				|-->
				<!--<a href="http://www.anotherblogblog.co.uk/pages/policy">policy</a>
				|-->
				<a href="mailto:mr.brompton@mail.com">Contact</a>
				<!--|
				<a href="">Support</a>
				-->
				</p>
				<p>This page is a product of Matthew Brompton, content &copy; 2017 Code is free to share</p>
			</div>
		</footer>
	</body>
</html>
